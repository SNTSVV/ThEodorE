/**
 * Copyright by University of Luxembourg 2019-2020.
 * Developed by Claudio Menghi, claudio.menghi@uni.lu, University of Luxembourg.
 * Developed by Enrico Vigano, enrico.vigano@ext.uni.lu, University of Luxembourg
 * Developed by Domenico Bianculli, domenico.bianculli@uni.lu, University of Luxembourg.
 * Developed by Lionel Briand,lionel.briand@uni.lu, University of Luxembourg.
 */
/*
 * generated by Xtext 2.16.0
 */
package lu.svv.theodore.generator

import java.io.File
import java.io.FileNotFoundException
import java.util.ArrayList
import java.util.HashSet
import java.util.Scanner
import java.util.Comparator
import lu.svv.theodore.hls.And
import lu.svv.theodore.hls.ConstantVariableRef
import lu.svv.theodore.hls.DoubleNumber
import lu.svv.theodore.hls.Expression
import lu.svv.theodore.hls.Fall
import lu.svv.theodore.hls.GenericTerm
import lu.svv.theodore.hls.GenericTermBrackets
import lu.svv.theodore.hls.GenericTermExponential
import lu.svv.theodore.hls.GenericTermMulOrDiv
import lu.svv.theodore.hls.GenericTermPlusOrMinus
import lu.svv.theodore.hls.Hls
import lu.svv.theodore.hls.Implication
import lu.svv.theodore.hls.IntNumber
import lu.svv.theodore.hls.NegativeDoubleNumber
import lu.svv.theodore.hls.NegativeIntNumber
import lu.svv.theodore.hls.NumericVariable
import lu.svv.theodore.hls.Or
import lu.svv.theodore.hls.Oscillation
import lu.svv.theodore.hls.Overshoot
import lu.svv.theodore.hls.Requirement
import lu.svv.theodore.hls.RetrieveSampleFromTimeStamp
import lu.svv.theodore.hls.RetrieveTimeStampFromSample
import lu.svv.theodore.hls.Rise
import lu.svv.theodore.hls.SampleQuantifier
import lu.svv.theodore.hls.SampleTerm
import lu.svv.theodore.hls.SampleTermBrackets
import lu.svv.theodore.hls.SampleTermExponential
import lu.svv.theodore.hls.SampleTermMulOrDiv
import lu.svv.theodore.hls.SampleTermPlusOrMinus
import lu.svv.theodore.hls.SampleTraceEnd
import lu.svv.theodore.hls.SampleVariable
import lu.svv.theodore.hls.SampleVariableRef
import lu.svv.theodore.hls.Signal
import lu.svv.theodore.hls.Specitication
import lu.svv.theodore.hls.Spike
import lu.svv.theodore.hls.TermRelation
import lu.svv.theodore.hls.TimeQuantifier
import lu.svv.theodore.hls.TimeTerm
import lu.svv.theodore.hls.TimeTermBrackets
import lu.svv.theodore.hls.TimeTermExponential
import lu.svv.theodore.hls.TimeTermMulOrDiv
import lu.svv.theodore.hls.TimeTermPlusOrMinus
import lu.svv.theodore.hls.TimeTraceEnd
import lu.svv.theodore.hls.TimeVariable
import lu.svv.theodore.hls.TimeVariableRef
import lu.svv.theodore.hls.Trace
import lu.svv.theodore.hls.Undershoot
import lu.svv.theodore.hls.ValueTermBrackets
import lu.svv.theodore.hls.ValueTermExponential
import lu.svv.theodore.hls.ValueTermGetSampleS
import lu.svv.theodore.hls.ValueTermGetSampleT
import lu.svv.theodore.hls.ValueTermMulOrDiv
import lu.svv.theodore.hls.ValueTermPlusOrMinus
import lu.svv.theodore.hls.VariableQuantifier
import lu.svv.theodore.preprocessing.Preprocessing
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.Negation
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lu.svv.theodore.hls.Variable
import lu.svv.theodore.hls.impl.SignalImpl
import java.util.Arrays
import java.util.IntSummaryStatistics
import java.util.HashMap
import java.util.Map.Entry
import lu.svv.theodore.hls.GenericTermRetrieveSampleFromTimeStamp
import lu.svv.theodore.hls.GenericTermRetrieveTimeStampFromSample
import lu.svv.theodore.hls.Neg
import java.util.List

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HlsGenerator extends AbstractGenerator {

	private val uri = URI.createPlatformResourceURI("neverland", true)

	var logsNumberOfEntries = new ArrayList<Integer>()
	var logsNumberOfEntriesIntermediate = new ArrayList<Integer>()
	var overshootquantcournter = 0;
	var undershootquantcournter = 0;
	var risequantcournter = 0;
	var fallquantcournter = 0;

	var Long minDeltaTime=Long.MAX_VALUE;
	var Long maxDeltaTime=Long.MAX_VALUE;

	var nummax = 0;
	var nummin = 0;
	var spikecounter = 0;
	var osccounter = 0;

	var definitions = ''
	var double sampleStep = 1.0
	var double firstTimeStamp = 0
	var double lastTimeStamp = 0
	var int lastSample = 0
	var timestamps = new ArrayList();
	var sampleStepIsConstant = false
	var timeindex = 0
	var generate = false

	var space = '\t'

	def double getNumber(Expression expression) {
		var double rate
		switch (expression) {
			IntNumber: {
				val number = (expression as IntNumber).value as double
				rate = number
			}
			DoubleNumber: {
				val upper = expression.upper as Integer
				val lower = expression.lower as Integer
				val double number = Double.parseDouble(upper + "." + lower);
				rate = number
			}
		}
		return rate
	}

	def String time2sampleText(String time) {
		var text = ""
		var value = ""
		if (sampleStepIsConstant)
		{
			value = '(' + time + '-' + firstTimeStamp + ')/' + sampleStep
			text += "ToInt(RealVal(0)+" + value + ")"
		}
		if (!sampleStepIsConstant) {
			timeindex++
			for (var i = 0; i < timestamps.length-1 ; i++) {
				if (i == 0) {
					value += "((2*(" + time + "<=" + timestamps.get(i) + ")/2)*" + i + ")";

				}
				if (i == timestamps.length - 1) {
					value += "+((2*(" + timestamps.get(i) + ">=" + time + ")/2)*" + (i) + ")";
				} else {
					value +=
						"+((2*(" + timestamps.get(i) + "<=" + time + ")*(" + time + "<" + timestamps.get(i + 1) +
							")/2)*" + (i + 1) + ")";
				}

			}

			definitions += '\n' + space + 's_' + timeindex + '=' + value
			text += 's_' + timeindex
		}

		return text;

	}

	def String sample2timeText(String sample) {
		var time = '((' + sample + ')/' + sampleStep + ')+' + firstTimeStamp + ')'

		return time
	}

	def String formulaRecursion(Expression expression) {
		var text = ''
		switch (expression) {
			And: {
				val left = formulaRecursion(expression.left)
				val right = formulaRecursion(expression.right)
				val op = expression.op
				text += op + "(" + left + ", " + right + ")"
			}
			Or: {
				val left = formulaRecursion(expression.left)
				val right = formulaRecursion(expression.right)
				val op = expression.op
				text += op + "(" + left + ", " + right + ")"
			}
			Neg: {
				val value = formulaRecursion(expression.neg)
				text += "Not(" + value + ')'
			}
			Implication: {
				val left = formulaRecursion(expression.left)
				val right = formulaRecursion(expression.right)
				text += "Implies(" + left + ", " + right + ")"
			}
			TimeQuantifier: {
				val op = expression.op as String
				var String connector
				if (op == 'ForAll') {
					connector = 'Implies'
				}
				if (op == 'Exists') {
					connector = 'And'
				}
				var function = expression.function.name as String

				if (expression.lower !== null && expression.upper !== null && expression.bracketup !== null &&
					expression.bracketdown !== null) {
					var down = arithmethicRecursion(expression.lower)
					var up = arithmethicRecursion(expression.upper)
					var bracketup = expression.bracketup
					var bracketdown = expression.bracketdown

					var major = "";
					var minor = "";

					if (bracketdown == "(") {
						minor = "<"
					} else {
						minor = "<="
					}
					if (bracketup == ")") {
						major = ">"
					} else {
						major = ">="
					}

					var interval = 'And(' + down + minor + function + ', ' + function + minor + up + ')'
					var String intervalDefinition = '\n' + space + 'interval_' + function + '=' + interval
					saveIntervals(intervalDefinition)
				}

				if (expression.suchthat !== null) {
					var conditions = expression.suchthat
					saveConditions(conditions, function)

				}

				text +=
					op + '([' + function + '], ' + connector + '(interval_' + function + ', conditions_' + function +
						'))'
			}
			SampleQuantifier: {
				val op = expression.op as String
				var String connector
				if (op == 'ForAll') {
					connector = 'Implies'
				}
				if (op == 'Exists') {
					connector = 'And'
				}
				var samplevariable = expression.function.name as String

				if (expression.lower !== null && expression.upper !== null && expression.bracketup !== null &&
					expression.bracketdown !== null) {
					var lowerBound = arithmethicRecursion(expression.lower)
					var upperBound = arithmethicRecursion(expression.upper)
					var bracketup = expression.bracketup
					var bracketdown = expression.bracketdown

					var major = "";
					var minor = "";

					if (bracketdown == "(") {
						minor = "<"
					} else {
						minor = "<="
					}
					if (bracketup == ")") {
						major = ">"
					} else {
						major = ">="
					}

					var interval = 'And(' + samplevariable + major + lowerBound + ', ' + samplevariable + minor +
						upperBound + ')'
					var String intervalDefinition = '\n' + space + 'interval_' + samplevariable + '=' + interval
					saveIntervals(intervalDefinition)
				}

				if (expression.suchthat !== null) {
					var conditions = expression.suchthat
					saveConditions(conditions, samplevariable)
				}

				text +=
					op + '([' + samplevariable + '], ' + connector + '(interval_' + samplevariable + ', conditions_' +
						samplevariable + '))'
			}
			VariableQuantifier: {
				val op = expression.op as String
				var String connector
				if (op == 'ForAll') {
					connector = 'Implies'
				}
				if (op == 'Exists') {
					connector = 'And'
				}
				var function = expression.function.name as String;

				if (expression.lower !== null && expression.upper !== null && expression.bracketup !== null &&
					expression.bracketdown !== null) {
					var down = arithmethicRecursion(expression.lower)
					var up = arithmethicRecursion(expression.upper)
					var bracketup = expression.bracketup
					var bracketdown = expression.bracketdown

					var major = "";
					var minor = "";

					if (bracketdown == "(") {
						minor = "<"
					} else {
						minor = "<="
					}
					if (bracketup == ")") {
						major = ">"
					} else {
						major = ">="
					}

					var interval = 'And(' + function + minor + up + ', ' + function + major + down + ')'
					var String intervalDefinition = '\n' + space + 'interval_' + function + '=' + interval
					saveIntervals(intervalDefinition)
					var conditions = expression.suchthat
					saveConditions(conditions, function)
					text +=
					op + '([' + function + '], ' + connector + '(interval_' + function + ', conditions_' + function +
						'))'


				}
				else {
					var conditions = expression.suchthat
					saveConditions(conditions, function)
					text +=
					op + '([' + function + '], ' +  'conditions_'  + function + ')'

				}


			}
			TermRelation: {
				val op = expression.op as String
				text += arithmethicRecursion(expression.left) + op + arithmethicRecursion(expression.right)
			}
			Overshoot: {
				val signal = arithmethicRecursion(expression.function)
				val mon = expression.mon
				var bracketup = expression.bracketup
				var bracketdown = expression.bracketdown

				var major = "";
				var minor = "";

				if (bracketdown == "(") {
					minor = "<"
				} else {
					minor = "<="
				}
				if (bracketup == ")") {
					major = ">"
				} else {
					major = ">="
				}
				var tl = arithmethicRecursion(expression.lowertime)
				var tu = arithmethicRecursion(expression.uppertime)

				val value1 = arithmethicRecursion(expression.value1);

				val value2 = arithmethicRecursion(expression.value2);

				var t = "t_Overshoot_" + overshootquantcournter;
				var t1 = "t1_Overshoot_" + overshootquantcournter;

				definitions +=
					'\n' + space + "t_Overshoot_" + overshootquantcournter + "=Real('t_Overshoot_" +
						overshootquantcournter + "') ";
				definitions +=
					'\n' + space + "t1_Overshoot_" + overshootquantcournter + "=Real('t1_Overshoot_" +
						overshootquantcournter + "') ";

				var interval_t_def = 'And(' + t + major + tl + ', ' + t + minor + tu + ')'
				var interval_t_id = 'interval_' + t;

				var String interval_t_Def = '\n' + space + interval_t_id + '=' + interval_t_def;

				saveIntervals(interval_t_Def)

				var interval_t1_def = 'And(' + t1 + major + t + ', ' + t1 + minor + tu + ')'
				var interval_t1_id = 'interval_' + t1;

				var String interval_t1_Def = '\n' + space + interval_t1_id + '=' + interval_t1_def;

				saveIntervals(interval_t1_Def)

				if (mon !== null) {
					var samplet2 = "t2_Overshoot_" + overshootquantcournter;

					var samplet3 = "t3_Overshoot_" + overshootquantcournter;

					definitions +=
						'\n' + space + "t2_Overshoot_" + overshootquantcournter + "=Int('t2_Overshoot_" +
							overshootquantcournter + "') ";
					definitions +=
						'\n' + space + "t3_Overshoot_" + overshootquantcournter + "=Int('t3_Overshoot_" +
							overshootquantcournter + "') ";

					var interval_t2_def = 'And(' + this.sample2timeText(samplet2) + ">" + tl + ', ' +
						this.sample2timeText(samplet2) + "<" + t + ')'
					var interval_t2_id = 'interval_' + samplet2;

					var String interval_t2_Def = '\n' + space + interval_t2_id + '=' + interval_t2_def;

					saveIntervals(interval_t2_Def)

					var interval_t3_def = 'And(' + samplet3 + ">" + samplet2 + ', ' + samplet3 + "<=" +
						sample2timeText(t) + ')'
					var interval_t3_id = 'interval_' + samplet3;

					var String interval_t3_Def = '\n' + space + interval_t3_id + '=' + interval_t3_def;

					saveIntervals(interval_t3_Def)

					var formula_def =
						'\n' + space + 'conditions_overshoot_' + overshootquantcournter + '=' + 'Exists([' + t +
							'], And(' + interval_t_id + ',
							And(And(' + signal + '[' + time2sampleText(t) + ']>=' + value1 + ',' + 'ForAll([' + t1 + '],
								Implies(' + 'And(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) +
							']<=((' + value1 + ')+(' + value2 + '))' + ')))),' + 'ForAll([' + samplet2 + '],
								Implies(' + 'And(' + interval_t2_id + ',' + 'ForAll([' + samplet3 + '],
												Implies(' + interval_t3_id + ',' + signal + '[' + samplet2 + ']<=' +
							signal + '[' + samplet3 + ']' + ')))))' + ')))'

					definitions += formula_def;

					text += 'conditions_overshoot_' + overshootquantcournter

				} else {

					var formula_def =
						'\n' + space + 'conditions_overshoot_' + overshootquantcournter + '=' + 'Exists([' + t +
							'], And(' + interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']>=' + value1 + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']<=(' +
							value1 + '+' + value2 + ')' + ')))))'
					definitions += formula_def;

					text += 'conditions_overshoot_' + overshootquantcournter
				}
				overshootquantcournter = overshootquantcournter++;

			}
			Undershoot: {

				definitions +=
					'\n' + space + "t_Undershoot_" + undershootquantcournter + "=Real('t_Undershoot_" +
						undershootquantcournter + "') ";
				definitions +=
					'\n' + space + "t1_Undershoot_" + undershootquantcournter + "=Real('t1_Undershoot_" +
						undershootquantcournter + "') ";

				val signal = arithmethicRecursion(expression.function)
				val mon = expression.mon
				var bracketup = expression.bracketup
				var bracketdown = expression.bracketdown

				var major = "";
				var minor = "";

				if (bracketdown == "(") {
					minor = "<"
				} else {
					minor = "<="
				}
				if (bracketup == ")") {
					major = ">"
				} else {
					major = ">="
				}
				var tl = arithmethicRecursion(expression.lowertime)
				var tu = arithmethicRecursion(expression.uppertime)

				val value1 = arithmethicRecursion(expression.value1);

				val value2 = arithmethicRecursion(expression.value2);

				var t = "t_Undershoot_" + undershootquantcournter;
				var t1 = "t1_Undershoot_" + undershootquantcournter;

				var interval_t_def = 'And(' + t + major + tl + ', ' + t + minor + tu + ')'
				var interval_t_id = 'interval_' + t;

				var String interval_t_Def = '\n' + space + interval_t_id + '=' + interval_t_def;

				saveIntervals(interval_t_Def)

				var interval_t1_def = 'And(' + t1 + major + t + ', ' + t1 + minor + tu + ')'
				var interval_t1_id = 'interval_' + t1;

				var String interval_t1_Def = '\n' + space + interval_t1_id + '=' + interval_t1_def;

				saveIntervals(interval_t1_Def)

				if (mon !== null) {
					var samplet2 = "t2_Undershoot_" + undershootquantcournter;

					var samplet3 = "t3_Undershoot_" + undershootquantcournter;

					var interval_t2_def = 'And(' + sample2timeText(samplet2) + ">" + tl + ', ' +
						sample2timeText(samplet2) + "<" + t + ')'
					var interval_t2_id = 'interval_' + samplet2;

					var String interval_t2_Def = '\n' + space + interval_t2_id + '=' + interval_t2_def;

					saveIntervals(interval_t2_Def)

					var interval_t3_def = 'And(' + samplet3 + ">" + samplet2 + ', ' + sample2timeText(samplet3) + "<=" +
						t + ')'
					var interval_t3_id = 'interval_' + samplet3;

					var String interval_t3_Def = '\n' + space + interval_t3_id + '=' + interval_t3_def;

					definitions +=
						'\n' + space + "t2_Undershoot_" + undershootquantcournter + "=Int('t2_Undershoot_" +
							undershootquantcournter + "') ";
					definitions +=
						'\n' + space + "t3_Undershoot_" + undershootquantcournter + "=Int('t3_Undershoott_" +
							undershootquantcournter + "') ";

					saveIntervals(interval_t3_Def)

					var formula_def =
						'\n' + space + 'conditions_Undershoot_' + undershootquantcournter + '=' + 'Exists([' + t +
							'], And(' + interval_t_id + ',
							And(And(' + signal + '[' + time2sampleText(t) + ']>=' + value1 + ',' + 'ForAll([' + t1 + '],
								Implies(' + 'And(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) +
							']>=((' + value1 + ')+(' + value2 + '))' + ')))),' + 'ForAll([' + samplet2 + '],
								Implies(' + interval_t2_id + ',' + 'ForAll([' + samplet3 + '],
												Implies(' + 'And(' + interval_t3_id + ',' + signal + '[' + samplet2 +
							']<=' + signal + '[' + samplet3 + ']' + ')))))' + ')))'
					definitions += formula_def;
					text += 'conditions_Undershoot_' + undershootquantcournter

				} else {

					var formula_def =
						'\n' + space + 'conditions_Undershoot_' + undershootquantcournter + '=' + 'Exists([' + t +
							'], And(' + interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']<=' + value1 + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']>=(' +
							value1 + '+' + value2 + ')' + ')))))'

					definitions += formula_def;
					text += 'conditions_Undershoot_' + undershootquantcournter
				}
				undershootquantcournter = undershootquantcournter++;

			}
			Rise: {
				val signal = arithmethicRecursion(expression.function)
				val mon = expression.mon
				var bracketup = expression.bracketup
				var bracketdown = expression.bracketdown

				var major = "";
				var minor = "";

				if (bracketdown == "(") {
					minor = "<"
				} else {
					minor = "<="
				}
				if (bracketup == ")") {
					major = ">"
				} else {
					major = ">="
				}
				var tl = arithmethicRecursion(expression.lowertime)

				var tu = arithmethicRecursion(expression.uppertime)

				val valuerise = arithmethicRecursion(expression.valuerise);

				var t = "t_Rise_" + risequantcournter;
				var t1 = "t1_Rise_" + risequantcournter;

				definitions +=
					'\n' + space + "t_Rise_" + risequantcournter + "=Real('t_Rise_" + risequantcournter + "') ";
				definitions +=
					'\n' + space + "t1_Rise_" + risequantcournter + "=Real('t1_Rise_" + risequantcournter + "') ";

				var interval_t_def = 'And(' + t + major + tl + ', ' + t + minor + tu + ')'
				var interval_t_id = 'interval_' + t;

				var String interval_t_Def = '\n' + space + interval_t_id + '=' + interval_t_def;

				saveIntervals(interval_t_Def)

				var interval_t1_def = 'And(' + t1 + major + tl + ', ' + t1 + '<' + t + ')'
				var interval_t1_id = 'interval_' + t1;

				var String interval_t1_Def = '\n' + space + interval_t1_id + '=' + interval_t1_def;

				saveIntervals(interval_t1_Def)

				if (mon !== null) {
					var samplet2 = "t2_Rise_" + risequantcournter;

					var samplet3 = "t3_Rise_" + risequantcournter;
					definitions +=
						'\n' + space + "t2_Rise_" + risequantcournter + "=Int('t2_Rise_" + risequantcournter + "') ";
					definitions +=
						'\n' + space + "t3_Rise_" + risequantcournter + "=Int('t3_Rise_" + risequantcournter + "') ";

					var interval_t2_def = 'And(' + sample2timeText(samplet2) + ">" + tl + ', ' +
						sample2timeText(samplet2) + "<" + t + ')'
					var interval_t2_id = 'interval_' + samplet2;

					var String interval_t2_Def = '\n' + space + interval_t2_id + '=' + interval_t2_def;

					saveIntervals(interval_t2_Def)

					var interval_t3_def = 'And(' + samplet3 + ">" + samplet2 + ', ' + sample2timeText(samplet3) + "<=" +
						t + ')'
					var interval_t3_id = 'interval_' + samplet3;

					var String interval_t3_Def = '\n' + space + interval_t3_id + '=' + interval_t3_def;

					saveIntervals(interval_t3_Def)

					var formula_def =
						'\n' + space + 'conditions_Rise_' + risequantcournter + '=' + 'Exists([' + t + '], And(' +
							interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']>=' + valuerise + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']<' +
							valuerise + ')),' + 'ForAll([' + samplet2 + '],
								Implies(' + interval_t2_id + ',' + 'ForAll([' + samplet3 + '],
												Implies(' + interval_t3_id + ',' + signal + '[' + samplet2 + ']<' +
							signal + '[' + samplet3 + ']' + '))))' + ')))'
					definitions += formula_def;
					text += 'conditions_Rise_' + risequantcournter

				} else {

					var formula_def =
						'\n' + space + 'conditions_Rise_' + risequantcournter + '=' + 'Exists([' + t + '], And(' +
							interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']>=' + valuerise + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']<' +
							valuerise + ')))))'
					definitions += formula_def;
					text += 'conditions_Rise_' + risequantcournter
				}
				risequantcournter = risequantcournter++;

			}
			Fall: {
				val signal = arithmethicRecursion(expression.function)
				val mon = expression.mon
				var bracketup = expression.bracketup
				var bracketdown = expression.bracketdown

				var major = "";
				var minor = "";

				if (bracketdown == "(") {
					minor = "<"
				} else {
					minor = "<="
				}
				if (bracketup == ")") {
					major = ">"
				} else {
					major = ">="
				}
				var tl = arithmethicRecursion(expression.lowertime)

				var tu = arithmethicRecursion(expression.uppertime)

				val valuefall = arithmethicRecursion(expression.valuerise);

				var t = "t_Fall_" + fallquantcournter;
				var t1 = "t1_Fall_" + fallquantcournter;
				definitions +=
					'\n' + space + "t_Fall_" + fallquantcournter + "=Real('t_Fall_" + fallquantcournter + "') ";
				definitions +=
					'\n' + space + "t1_Fall_" + fallquantcournter + "=Real('t1_Fall_" + fallquantcournter + "') ";

				var interval_t_def = 'And(' + t + major + tl + ', ' + t + minor + tu + ')'
				var interval_t_id = 'interval_' + t;

				var String interval_t_Def = '\n' + space + interval_t_id + '=' + interval_t_def;

				saveIntervals(interval_t_Def)

				var interval_t1_def = 'And(' + t1 + major + tl + ', ' + t1 + minor + t + ')'
				var interval_t1_id = 'interval_' + t1;

				var String interval_t1_Def = '\n' + space + interval_t1_id + '=' + interval_t1_def;

				saveIntervals(interval_t1_Def)

				if (mon !== null) {
					var samplet2 = "t2_Fall_" + fallquantcournter;

					var samplet3 = "t3_Fall_" + fallquantcournter;
					definitions +=
						'\n' + space + "t2_Fall_" + fallquantcournter + "=Int('t2_Fall_" + fallquantcournter + "') ";
					definitions +=
						'\n' + space + "t3_Fall_" + fallquantcournter + "=Int('t3_Fall_" + fallquantcournter + "') ";

					var interval_t2_def = 'And(' + samplet2 + ">" + tl + ', ' + samplet2 + "<" + t + ')'
					var interval_t2_id = 'interval_' + samplet2;

					var String interval_t2_Def = '\n' + space + interval_t2_id + '=' + interval_t2_def;

					saveIntervals(interval_t2_Def)

					var interval_t3_def = 'And(' + samplet3 + ">" + samplet2 + ', ' + samplet3 + "<=" + t + ')'
					var interval_t3_id = 'interval_' + samplet3;

					var String interval_t3_Def = '\n' + space + interval_t3_id + '=' + interval_t3_def;

					saveIntervals(interval_t3_Def)

					var formula_def =
						'\n' + space + 'conditions_Fall_' + fallquantcournter + '=' + 'Exists([' + t + '], And(' +
							interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']<=' + valuefall + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']>' +
							valuefall + ')),' + 'ForAll([' + samplet2 + '],
								Implies(' + interval_t2_id + ',' + 'ForAll([' + samplet3 + '],
												Implies(' + interval_t3_id + ',' + signal + '[' + samplet2 + ']<' +
							signal + '[' + samplet3 + ']' + '))))' + ')))'

					definitions += formula_def;
					text += 'conditions_Fall_' + fallquantcournter

				} else {
					var formula_def =
						'\n' + space + 'conditions_Fall_' + fallquantcournter + '=' + 'Exists([' + t + '], And(' +
							interval_t_id + ',
							And(' + signal + '[' + time2sampleText(t) + ']<=' + valuefall + ',' + 'ForAll([' + t1 + '],
								Implies(' + interval_t1_id + ',' + signal + '[' + time2sampleText(t1) + ']>' +
							valuefall + ')))))'
					definitions += formula_def;
					text += 'conditions_Fall_' + fallquantcournter
				}
				fallquantcournter = fallquantcournter++;

			}
			Spike: {

				val signal = arithmethicRecursion(expression.function)

				var t1spike = "t1spike" + spikecounter;
				var t2spike = "t2spike" + spikecounter;
				var t3spike = "t3spike" + spikecounter;

				val opwidth = expression.opwidth as String
				val opamp = expression.opamp as String

				val width = arithmethicRecursion(expression.width);
				val ampl = arithmethicRecursion(expression.ampl);

				definitions += '\n' + space + "t1spike" + spikecounter + "= Real('t1spike" + spikecounter + "')";
				definitions += '\n' + space + "t2spike" + spikecounter + "= Real('t2spike" + spikecounter + "')";
				definitions += '\n' + space + "t3spike" + spikecounter + "= Real('t3spike" + spikecounter + "')";

				var tl = arithmethicRecursion(expression.lowertime)

				var tu = arithmethicRecursion(expression.uppertime)

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax=uni_m_max(signal, t1spike, tl, t2spike);
				definitions +=
					'\n' + space + "conditions_Maxa_" + spikecounter + "=" + unimax;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";
				val unimin=uni_sm_min(signal, t2spike, t1spike, t3spike);
				definitions +=
					'\n' + space + "conditions_Minb_" + spikecounter + "=" +
						unimin;
				nummin = nummin + 1;

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax2=uni_m_max(signal, t3spike, t2spike, tu);
				definitions +=
					'\n' + space + "conditions_Maxc_" + spikecounter + "=" + unimax2;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";

				val unimin2=uni_m_min(signal, t1spike, tl, t2spike)
				definitions +=
					'\n' + space + "conditions_Mind_" + spikecounter + "=" + unimin2;
				nummin = nummin + 1;

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax3=uni_sm_max(signal, t2spike, t1spike, t3spike)
				definitions +=
					'\n' + space + "conditions_Maxe_" + spikecounter + "=" +
						unimax3;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";

				val unimin3=uni_m_min(signal, t3spike, t2spike, tu)
				definitions +=
					'\n' + space + "conditions_Minf_" + spikecounter + "=" + unimin3;
				nummin = nummin + 1;

				var exp = ""
				if (expression.width !== null && expression.ampl !== null) {
					var exp1= "And(Or(" + "(2*((" + signal +
						"[" + time2sampleText(t1spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "])>=(" + signal +
						"[" + time2sampleText(t3spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "]))*" + "(" + signal +
						"[" + time2sampleText(t1spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "]"+ opamp + ampl + ")/2)==1" + "," + "(2*((" + signal +
						"[" + time2sampleText(t1spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "])<(" + signal +
						"[" + time2sampleText(t3spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "]))*" + "(" + signal +
						"[" + time2sampleText(t3spike) + "]-" + signal +
						"[" + time2sampleText(t2spike) + "]"+ opamp + ampl + ")/2)==1" + ")" + "," + "(" + t2spike + "-" +
							t1spike + ")" + opwidth + width + ")";

					var exp2= "And(Or((2*" + "((" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t1spike) + "])>=(" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t3spike) + "]))*" + "(" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t3spike) + "]"+ opamp + ampl + ")/2)==1" + "," + "(2*((" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t1spike) + "])<(" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t3spike) + "]))*" + "(" + signal +
						"[" + time2sampleText(t2spike) + "]-" + signal +
						"[" + time2sampleText(t1spike) + "]"+ opamp + ampl + ")/2)==1" + ")" + "," + "(" + t2spike + "-" +
							t1spike + ")" + opwidth + width + ")";

					exp = "Or(" +
						// max min max
						"And(" + "conditions_Maxa_" + spikecounter + "," + "conditions_Minb_" +
							spikecounter + "," + "conditions_Maxc_" + spikecounter + "," +exp1+")," +
							// min max min
							"And(" + "conditions_Mind_" + spikecounter + "," + "conditions_Maxe_" +
							spikecounter + "," + "conditions_Minf_" + spikecounter + "," + exp2+"))";

					definitions +=
							'\n' + space + 'conditions_Spike_' + spikecounter + '=' + "Exists([" + t1spike + "]," +
								"And(" + tl + "<=" + t1spike + "," + "Exists([" + t2spike + "]," + "And(" + t1spike +
								"<" + t2spike + "," + "Exists([" + t3spike + "]," + "And(And(" + t2spike + "<" +
								t3spike + "," + t3spike + "<=" + tu + ")," + exp + "))))))"
				} else {
					if (expression.width !== null) {


						exp = "And(Or(" + // max min max
						"And(And(" + "conditions_Maxa_" + spikecounter + "," + "conditions_Minb_" + spikecounter +
							")," + "conditions_Maxc_" + spikecounter + ")," + // min max min
							"And(And(" + "conditions_Mind_" + spikecounter + "," + "conditions_Maxe_" + spikecounter +
							")," + "conditions_Minf_" + spikecounter + ")," + "),(" + t2spike + "-" + t1spike + ")" +
							opwidth + width + ")"
						definitions +=
							'\n' + space + 'conditions_Spike_' + spikecounter + '=' + "Exists([" + t1spike + "]," +
								"And(" + tl + "<=" + t1spike + "," + "Exists([" + t2spike + "]," + "And(" + t1spike +
								"<" + t2spike + "," + "Exists([" + t3spike + "]," + "And(And(" + t2spike + "<" +
								t3spike + "," + t3spike + "<=" + tu + ")," + exp + "))))))"
					} else {
						if (expression.ampl !== null) {

							var exp1="Or((2*" + "((" + signal +
							"[" + time2sampleText(t1spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "])>=(" + signal +
							"[" + time2sampleText(t3spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "]))*" + "(" + signal +
							"[" + time2sampleText(t1spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "]" + opamp + ampl + ")" +
								"/2)==1,(2*" +
								"((" + signal +
							"[" + time2sampleText(t1spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "])<(" + signal +
							"[" + time2sampleText(t3spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "]))*" + "(" + signal +
							"[" + time2sampleText(t3spike) + "]-" + signal +
							"[" + time2sampleText(t2spike) + "]"+ opamp + ampl + ")/2)==1)";

							var exp2="Or((2*" + "((" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal +
							"[" + time2sampleText(t1spike) + "])>=(" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal +
							"[" + time2sampleText(t3spike) + "]))*" + "(" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal +
							"[" + time2sampleText(t3spike) + "]"+ opamp + ampl + ")" + "/2)==1,(2*" +
								"((" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal +
							"[" + time2sampleText(t1spike) + "])<(" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal  +
							"[" + time2sampleText(t3spike) + "]))*" + "(" + signal +
							"[" + time2sampleText(t2spike) + "]-" + signal +
							"[" + time2sampleText(t1spike) + "]"+ opamp + ampl + ")/2)==1)"

							exp = "Or(" +
							// max min max
							"And(" + "conditions_Maxa_" + spikecounter + "," + "conditions_Minb_" +
								spikecounter + "," + "conditions_Maxc_" + spikecounter + ","+exp1+ "),"+
							// min max min
							"And(" + "conditions_Mind_" + spikecounter + "," + "conditions_Maxe_" +
								spikecounter + "," + "conditions_Minf_" + spikecounter + ","+exp2+  "))"

							var formula_def =
								'\n' + space + 'conditions_Spike_' + spikecounter + '=' + "Exists([" + t1spike + "]," +
									"And(" + tl + "<=" + t1spike + "," + "Exists([" + t2spike + "]," +
									"And(" + t1spike + "<" + t2spike + "," + "Exists([" + t3spike + "]," +
									"And(And(" + t2spike + "<" + t3spike + "," + t3spike + "<=" + tu + ")," + exp +
									"))))))"
							definitions += formula_def;

						} else {
							exp = "Or(" + // max min max
							"And(And(" + "conditions_Maxa_" + spikecounter + "," + "conditions_Minb_" + spikecounter +
								")," + "conditions_Maxc_" + spikecounter + ")," + // min max min
								"And(And(" + "conditions_Mind_" + spikecounter + "," + "conditions_Maxe_" +
								spikecounter + ")," + "conditions_Minf_" + spikecounter + ")," + ")"
							var formula_def =
								'\n' + space + 'conditions_Spike_' + spikecounter + '=' + "Exists([" + t1spike + "]," +
									"And(" + tl + "<=" + t1spike + "," + "Exists([' + t2spike + ']," +
									"And(" + t1spike + "<" + t2spike + "," + "Exists([' + t3spike + ']," +
									"And(And(" + t2spike + "<" + t3spike + "," + t3spike + "<=" + tu + ")," + exp +
									"))))))"
							definitions += formula_def;
						}
					}
				}

				text += 'conditions_Spike_' + spikecounter
				spikecounter = spikecounter + 1;

			}
			Oscillation: {

				val signal = arithmethicRecursion(expression.function)

				var t1osc = "t1osc" + osccounter;
				var t2osc = "t2osc" + osccounter;
				var t3osc = "t3osc" + osccounter;
				var t4osc = "t4osc" + osccounter;
				var t5osc = "t5osc" + osccounter;

				definitions += '\n' + space + t1osc + "= Real('" + t1osc + "')";
				definitions += '\n' + space + t2osc + "= Real('" + t2osc + "')";
				definitions += '\n' + space + t3osc + "= Real('" + t3osc + "')";
				definitions += '\n' + space + t4osc + "= Real('" + t4osc + "')";
				definitions += '\n' + space + t5osc + "= Real('" + t5osc + "')";

				var tl = arithmethicRecursion(expression.lowertime)

				var tu = arithmethicRecursion(expression.uppertime)

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax=uni_sm_max(signal, t2osc, t1osc, t3osc)
				definitions +=
					'\n' + space + "conditions_Maxa_" + osccounter + "=" + unimax;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";

				val unimin=uni_sm_min(signal, t3osc, t2osc, t4osc)
				definitions +=
					'\n' + space + "conditions_Minb_" + osccounter + "=" + unimin;
				nummin = nummin + 1;

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax2=uni_sm_max(signal, t4osc, t3osc, t5osc);
				definitions +=
					'\n' + space + "conditions_Maxc_" + osccounter + "=" + unimax2;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";

				val unimin2=uni_sm_min(signal, t2osc, t1osc, t3osc)
				definitions +=
					'\n' + space + "conditions_Mind_" + osccounter + "=" + unimin2;
				nummin = nummin + 1;

				definitions += '\n' + space + "sample_1dec_max" + nummax + "= Int('sample_1dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_2dec_max" + nummax + "= Int('sample_2dec_max" + nummax + "')";
				definitions += '\n' + space + "sample_1inc_max" + nummax + "= Int('sample_1inc_max" + nummax + "')";
				definitions += '\n' + space + "sample_2inc_max" + nummax + "= Int('sample_2inc_max" + nummax + "')";

				val unimax3=uni_sm_max(signal, t3osc, t2osc, t4osc)
				definitions +=
					'\n' + space + "conditions_Maxe_" + osccounter + "=" + unimax3;
				nummax = nummax + 1;

				definitions += '\n' + space +  "sample_1inc_min" + nummin + "= Int('sample_1inc_min" + nummin + "')";
				definitions += '\n' + space +  "sample_2inc_min" + nummin + "= Int('sample_2inc_min" + nummin + "')";
				definitions += '\n' + space + "sample_1dec_min" + nummin + "= Int('sample_1dec_min" + nummin + "')";
				definitions += '\n' + space + "sample_2dec_min" + nummin + "= Int('sample_2dec_min" + nummin + "')";

				val unimin3=uni_sm_min(signal, t4osc, t3osc, t5osc)
				definitions +=
					'\n' + space + "conditions_Minf_" + osccounter + "=" + unimin3;
				nummin = nummin + 1;

				val oscp2pAmp = arithmethicRecursion(expression.oscp2pAmp)
				val oscperiod = arithmethicRecursion(expression.oscperiod)

				val opp2pamp = expression.opp2pamp as String
				val opperiod = expression.opperiod as String

				var exp = ""
				if (expression.oscp2pAmp !== null && expression.oscperiod !== null) {
					exp = "Or(" + // max min max
					"And(And(" + "conditions_Maxa_" + osccounter + "," + "conditions_Minb_" + osccounter +
						"," + "conditions_Maxc_" + osccounter + ")," +
						"And(" + signal + "[" + time2sampleText(t2osc) +
						"]-" + signal + "[" + time2sampleText(t3osc) + "]" + opp2pamp + oscp2pAmp + "," + signal + "[" +
						time2sampleText(t4osc) + "]-" + signal + "[" + time2sampleText(t3osc) + "]" + opp2pamp +
						oscp2pAmp + "," + "(" + t4osc + "-" + t2osc + ")" + opperiod + oscperiod + ")),"+
					// min max min
					"And(And(" + "conditions_Mind_" + osccounter + "," + "conditions_Maxe_" + osccounter +
						"," + "conditions_Minf_" + osccounter + "),"
						+ "And(" + signal + "[" + time2sampleText(t3osc) +
						"]-" + signal + "[" + time2sampleText(t2osc) + "]" + opp2pamp + oscp2pAmp + "," + signal + "[" +
						time2sampleText(t3osc) + "]-" + signal + "[" + time2sampleText(t4osc) + "]" + opp2pamp +
						oscp2pAmp + "" + "," + "(" + t4osc + "-" + t2osc + ")" + opperiod + oscperiod + ")))";
				} else {
					if (expression.oscperiod !== null) {
						exp = "And(Or(" + // max min max
						"And(And(" + "conditions_Maxa_" + osccounter + "," + "conditions_Minb_" + osccounter + ")," +
							"conditions_Maxc_" + osccounter + ")," + // min max min
							"And(And(" + "conditions_Mind_" + osccounter + "," + "conditions_Maxe_" + osccounter +
							")," + "conditions_Minf_" + osccounter + ")" + "),(" + t4osc + "-" + t2osc + ")" +
							opperiod + oscperiod + ")"
					} else {
						if (expression.oscp2pAmp !== null) {
							exp = "Or(" + // max min max
							"And(And(And(" + "conditions_Maxa_" + osccounter + "," + "conditions_Minb_" + osccounter +
								")," + "conditions_Maxc_" + osccounter + ")," + "And(" + signal + "[" +
								time2sampleText(t2osc) + "]-" + signal + "[" + time2sampleText(t3osc) + "]" + opp2pamp +
								oscp2pAmp + "," + signal + "[" + time2sampleText(t4osc) + "]-" + signal + "[" +
								time2sampleText(t3osc) + "]" + opp2pamp + oscp2pAmp + "))," + // min max min
								"And(And(And(" + "conditions_Mind_" + osccounter + "," +
								"conditions_Maxe_" + osccounter + ")," + "conditions_Minf_" + osccounter + ")," +
								"And(" + signal + "[" + time2sampleText(t3osc) + "]-" + signal + "[" +
								time2sampleText(t2osc) + "]" + opp2pamp + oscp2pAmp + "," + signal + "[" +
								time2sampleText(t3osc) + "]-" + signal + "[" + time2sampleText(t4osc) + "]" + opp2pamp +
								oscp2pAmp + ")" + "))";

						} else {
							exp = "Or(" + // max min max
							"And(And(" + "conditions_Maxa_" + osccounter + "," + "conditions_Minb_" + osccounter +
								")," + "conditions_Maxc_" + osccounter + ")," + // min max min
								"And(And(" + "conditions_Mind_" + osccounter + "," + "conditions_Maxe_" + osccounter +
								")," + "conditions_Minf_" + osccounter + ")" + ")"
						}
					}
				}

				var formula_def =
					'\n' + space + 'conditions_Osc_' + osccounter + '=' + "Exists([" + t1osc + "]," +
						"And(" + tl + "<=" + t1osc + "," + "Exists([" + t2osc + "]," + "And(" + t1osc + "<" + t2osc +
						"," + "Exists([" + t3osc + "]," + "And(" + t2osc + "<" + t3osc + "," + "Exists([" + t4osc +
						"]," + "And(" + t3osc + "<" + t4osc + "," + "Exists([" + t5osc + "]," +
						"And(And(" + t4osc + "<" + t5osc + "," + t5osc + "<=" + tu + ")," + exp + "))))))))))"
				definitions += formula_def;
				text += 'conditions_Osc_' + osccounter
				osccounter = osccounter + 1;

			}
		}
		return text
	}

	def String uni_m_max(String signal, String t, String tl, String tu) {


		var sample1increases = "sample_1inc_max" + nummax;
		var sample2increases = "sample_2inc_max" + nummax;


		var increases = "ForAll([" + sample1increases + "],
Implies(And(" + time2sampleText(tl) + "<=" + sample1increases + "," + sample1increases + "<=" + time2sampleText(t) + "),
ForAll([" + sample2increases + "],
Implies(And(" + sample1increases + "<=" + sample2increases + "," + sample2increases + "<=" +  time2sampleText(t) + ")," + signal + "[" + sample1increases + "]<=" +
			signal + "[" + sample2increases + "]))))";

		var sample1decreases = "sample_1dec_max" + nummax;
		var sample2decreases = "sample_2dec_max" + nummax;

		var decreases = "ForAll([" + sample1decreases + "],
Implies(And(" +  time2sampleText(t) + "<=" + sample1decreases + "," + sample1decreases + "<=" + time2sampleText(tu) + "),
ForAll([" + sample2decreases + "],
Implies(And(" + sample1decreases + "<=" + sample2decreases + "," + sample2decreases + "<=" + time2sampleText(tu) + "),
" + signal + "[" + sample1decreases + "]>=" + signal + "[" + sample2decreases + "]))))";

		var text = "And(" + increases + "," + decreases + ")"

		return text
	}

	def String uni_m_min(String signal, String t, String tl, String tu) {

		var sample1decreases = "sample_1dec_min" + nummin;
		var sample2decreases = "sample_2dec_min" + nummin;

		var decreases = "ForAll([" + sample1decreases + "],
Implies(And(" + time2sampleText(tl) + "<=" + sample1decreases + "," + sample1decreases + "<=" + time2sampleText(t) + "),
ForAll([" + sample2decreases + "],
Implies(And(" + sample1decreases + "<=" + sample2decreases + "," + sample2decreases + "<=" + time2sampleText(t) + "),
" + signal + "[" + sample1decreases + "]>=" + signal + "[" + sample2decreases + "]))))";

		var sample1increases =  "sample_1inc_min" + nummin;
		var sample2increases =  "sample_2inc_min" + nummin;

		var increases = "ForAll([" + sample1increases + "],
Implies(And(" + time2sampleText(t) + "<=" + sample1increases + "," + sample1increases + "<=" + time2sampleText(tu) + "),
ForAll([" + sample2increases + "],
Implies(And(" + sample1increases + "<=" + sample2increases + "," + sample2increases + "<=" + time2sampleText(tu)  + "),
" + signal + "[" + sample1increases + "]<=" + signal + "[" + sample2increases + "]))))";

		var text = "And(" + increases + "," + decreases + ")"

		return text
	}

	def String uni_sm_max(String signal, String t, String tl, String tu) {

		var sample1increases = "sample_1inc_max" + nummax;
		var sample2increases = "sample_2inc_max" + nummax;


		var increases = "ForAll([" + sample1increases + "],
Implies(And(" + time2sampleText(tl) + "<=" + sample1increases + "," + sample1increases + "<" + time2sampleText(t) + "),
ForAll([" + sample2increases + "],
Implies(And(" + sample1increases + "<" + sample2increases + "," + sample2increases + "<=" + time2sampleText(t) + "),"
+ signal + "[" + sample1increases + "]<" +
			signal + "[" + sample2increases + "]))))";

		var sample1decreases = "sample_1dec_max" + nummax;
		var sample2decreases = "sample_2dec_max" + nummax;

		var decreases = "ForAll([" + sample1decreases + "],
Implies(And(" + time2sampleText(t) + "<=" + sample1decreases + "," + sample1decreases + "<" + time2sampleText(tu) + "),
ForAll([" + sample2decreases + "],
Implies(And(" + sample1decreases + "<" + sample2decreases + "," + sample2decreases + "<=" + time2sampleText(tu) + "),"
+ signal + "[" + sample1decreases + "]>" +
			signal + "[" + sample2decreases + "]))))";

		var text ="And(" + increases + "," + decreases + ")"

		return text
	}

	def String uni_sm_min(String signal, String t, String tl, String tu) {


		var sample1decreases = "sample_1dec_min" + nummin;
		var sample2decreases = "sample_2dec_min" + nummin;

		var decreases = "ForAll([" + sample1decreases + "],
Implies(And(" + time2sampleText(tl) + "<=" + sample1decreases + "," + sample1decreases + "<" + time2sampleText(t) + "),
ForAll([" + sample2decreases + "],
Implies(And(" + sample1decreases + "<" + sample2decreases + "," + sample2decreases + "<=" + t + "),
" + signal + "[" + sample1decreases + "]>" + signal + "[" + sample2decreases + "]))))";

		var sample1increases =  "sample_1inc_min" + nummin;
		var sample2increases =  "sample_2inc_min" + nummin;

		var increases = "ForAll([" + sample1increases + "],
Implies(And(" + time2sampleText(t) + "<=" + sample1increases + "," + sample1increases + "<" + time2sampleText(tu) + "),
ForAll([" + sample2increases + "],
Implies(And(" + sample1increases + "<" + sample2increases + "," + sample2increases + "<=" + time2sampleText(tu) + "),
" + signal + "[" + sample1increases + "]<" + signal + "[" + sample2increases + "]))))";

		var text = "And(" + increases + "," + decreases + ")"

		return text
	}

	def String arithmethicRecursion(Expression expression) {
		var text = ""

		switch (expression) {
			TimeTerm: {
				text += (arithmethicRecursion(expression.timeTerm))
			}
			SampleTerm: {
				text += arithmethicRecursion(expression.sampleterm)
			}
			IntNumber: {
				val value = (expression as IntNumber).value
				var String body = '' + value
				if (expression.unit as String == '[h]') {
					body = '(' + value + '*3.6*1000000000)'
				}
				if (expression.unit as String == '[min]') {
					body = '(' + value + '*6*10000000)'
				}
				if (expression.unit as String == '[ms]') {
					body = '(' + value + '*1000)'
				}
				if (expression.unit as String == '[micros]') {
					body = '(' + value + '*1)'
				}
				if (expression.unit as String == '[nanos]') {
					body = '(' + value + '*0,001)'
				}
				if (expression.unit as String == '[s]') {
					body = '(' + value + '*1000000)'
				}
				text += body

			}
			NegativeIntNumber: {
				val number = (expression as NegativeIntNumber).value
				val value = '(-' + number + ')'

				if (expression.unit !== null) {
					if (expression.unit as String == '[h]') {
						text += '(' + value + '*3.6*1000000000)'
					}
					if (expression.unit as String == '[min]') {
						text += '(' + value + '*6*10000000)'
					}
					if (expression.unit as String == '[ms]') {
						text += '(' + value + '*1000)'
					}
					if (expression.unit as String == '[micros]') {
						text += '(' + value + '*1)'
					}
					if (expression.unit as String == '[nanos]') {
						text += '(' + value + '*0,001)'
					}
				} else {
					text += value
				}
			}
			DoubleNumber: {
				val upper = expression.upper
				val lower = expression.lower
				val value = upper + '.' + lower

				if (expression.unit !== null) {
					if (expression.unit as String == '[h]') {
						text += '(' + value + '*3.6*1000000000)'
					}
					if (expression.unit as String == '[min]') {
						text += '(' + value + '*6*10000000)'
					}
					if (expression.unit as String == '[ms]') {
						text += '(' + value + '*1000)'
					}
					if (expression.unit as String == '[micros]') {
						text += '(' + value + '*1)'
					}
					if (expression.unit as String == '[nanos]') {
						text += '(' + value + '*0,001)'
					}
					if (expression.unit as String == '[s]') {
						text += '(' + value + '*1000000)'
					}
				} else {
					text += value
				}
			}
			NegativeDoubleNumber: {
				val upper = expression.upper
				val lower = expression.lower
				val value = '-(' + upper + '.' + lower + ')'
				if (expression.unit !== null) {
					if (expression.unit as String == '[h]') {
						text += '(' + value + '*3.6*1000000000)'
					}
					if (expression.unit as String == '[min]') {
						text += '(' + value + '*6*10000000)'
					}
					if (expression.unit as String == '[ms]') {
						text += '(' + value + '*1000)'
					}
					if (expression.unit as String == '[micros]') {
						text += '(' + value + '*1)'
					}
					if (expression.unit as String == '[nanos]') {
						text += '(' + value + '*0,001)'
					}
					if (expression.unit as String == '[s]') {
						text += '(' + value + '*1000000)'
					}
				} else {
					text += value
				}
			}
			SampleTraceEnd: {
				text += lastSample
			}
			TimeTraceEnd: {
				text += lastTimeStamp
			}
			TimeTermExponential: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				text += left + '**' + right
			}
			SampleTermExponential: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				text += left + '**' + right
			}
			ValueTermExponential: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				text += left + '**' + right
			}
			TimeTermMulOrDiv: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			SampleTermMulOrDiv: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			ValueTermMulOrDiv: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			TimeTermPlusOrMinus: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			SampleTermPlusOrMinus: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			ValueTermPlusOrMinus: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			TimeTermBrackets: {
				val value = arithmethicRecursion(expression.expression)
				text += "(" + value + ')'
			}
			SampleTermBrackets: {
				val value = arithmethicRecursion(expression.expression)
				text += "(" + value + ')'
			}
			ValueTermBrackets: {
				val value = arithmethicRecursion(expression.expression)
				text += "(" + value + ')'
			}
			GenericTermRetrieveTimeStampFromSample: {
				var inside = arithmethicRecursion(expression.expression)
				text += 'timestamps[' + inside + ']';
			}
			GenericTermRetrieveSampleFromTimeStamp: {
				var inside = arithmethicRecursion(expression.expression)
				text += time2sampleText(inside)

			}
			ValueTermGetSampleT: {
				var samplevalue = time2sampleText(arithmethicRecursion(expression.inside))
				var signalName = expression.function.name
				text += signalName + "[" + samplevalue + "]";

			}
			ValueTermGetSampleS: {
				var samplevalue = arithmethicRecursion(expression.inside)
				var signalName = expression.function.name
				text += signalName + "[" + samplevalue + "]";

			}
			GenericTerm: {
				text += (arithmethicRecursion(expression.genericterm))
			}
			GenericTermPlusOrMinus: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			GenericTermMulOrDiv: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				val op = expression.op
				text += left + op + right
			}
			GenericTermExponential: {
				val left = arithmethicRecursion(expression.left)
				val right = arithmethicRecursion(expression.right)
				text += left + '**' + right
			}
			GenericTermBrackets: {
				val value = arithmethicRecursion(expression.expression)
				text += "(" + value + ')'
			}
			Variable: {
				if (expression instanceof SignalImpl) {
					text += expression.name
				} else {
					text += expression.variable.name
				}
			}
			SampleVariableRef: {
				text += expression.sampleVariable.name;
			}
			TimeVariableRef: {
				val value = expression.timeVariable.name;

				if (expression.unit !== null) {
					if (expression.unit as String == '[h]') {
						text += '(' + value + '*3.6*1000000000)'
					}
					if (expression.unit as String == '[min]') {
						text += '(' + value + '*6*10000000)'
					}
					if (expression.unit as String == '[s]') {
						text += '(' + value + '*1000000)'
					}
					if (expression.unit as String == '[ms]') {
						text += '(' + value + '*1000)'
					}
					if (expression.unit as String == '[micros]') {
						text += '(' + value + '*1)'
					}
					if (expression.unit as String == '[nanos]') {
						text += '(' + value + '*0,001)'
					}
				} else {
					text += value
				}
			}
			ConstantVariableRef: {
				text += expression.constantVariable.name;
			}
		}

		return text
	}

	def String processfile(IFileSystemAccess2 fsa, String filePath) {
		timestamps = new ArrayList();

		var signalEncoding = new StringBuilder(10000000)
		try {
			val myReader = new Scanner(fsa.readTextFile(filePath).toString);

			var index = 0;
			var header = true;
			var headers = new ArrayList();
			while (myReader.hasNextLine()) {
				val line = myReader.nextLine();
				if (header) {
					var name = true
					var time = true
					for (el : line.split(',')) {
						if (time) {
							headers.add("t");
							var dog = Double.parseDouble(el.toString)
							firstTimeStamp = dog
							signalEncoding.append(space + "timestamps=Array('timestamps', RealSort(), IntSort())\n");
							time = false
						} else {
							if (name) {
								headers.add(el);
								el ->
									signalEncoding.append(
										space + el.toString + "=Array('" + el.toString + "', RealSort(), IntSort())\n");
								name = false
							} else {
								name = true
							}
						}
					}
					header = false
				}
				var time = true;
				var name = true;
				var headerindex = 0;
				for (el : line.split(',')) {
					if (time) {
						el ->
							signalEncoding.append(
								space + "z3solver.add(timestamps[ " + index + "]==" + el.toString + ")\n");
						time = false
						headerindex = headerindex + 1;
						var dog2 = Double.parseDouble(el.toString)
						lastTimeStamp = dog2

						timestamps.add(Double.parseDouble(el.toString))
					} else {
						if (name) {
							name = false
						} else {
							el ->
								signalEncoding.append(
									space + "z3solver.add(" + headers.get(headerindex) + "[" + index + "]==" +
										el.toString + ")\n");
							headerindex = headerindex + 1;
							name = true
						}
					}

				}
				index = index + 1;
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();

		}
		return signalEncoding.toString() + "\n\n\n";
	}

	def String getSampleBuilder(String variablename, int numberofiterations) {
		var text = 'And(';
		var i = 0
		while (i <= numberofiterations) {
			if (i != 0) {
				text = space + text + ','
			}
			text = text + '\n' + 'Implies(And(timestamps[' + i + ']<= ' + variablename + ',timestamps[' + (i + 1) +
				'] > ' + variablename + '),sample' + variablename + '==' + i + ')'
			i = i + 1
		}
		text = text + ')'
		return text;
	}

	def int countTimestamps(IFileSystemAccess2 fsa, String filePath) {
		var index = 0;
		try {
			val myObj = new File(filePath);

			val myReader = new Scanner(fsa.readTextFile(filePath).toString);
			while (myReader.hasNextLine()) {
				index = index + 1
				myReader.nextLine;
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			println("******************||*||***PUT***||*||*******************")
			println("******************||*||***THE***||*||*******************")
			println("******************||*||**FILES**||*||*******************")
			println("******************||*||**HERE!**||*||*******************")
			println("Working Directory = " + System.getProperty("user.dir"));
		}
		return index
	}

	def String saveConditions(Expression definition, String name) {
		var conditions = formulaRecursion(definition)
		definitions += '\n' + space + 'conditions_' + name + '=' + conditions
	}

	def String saveIntervals(String interval) {
		definitions += '\n' + interval
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		minDeltaTime=Long.MAX_VALUE;
	 	maxDeltaTime=Long.MIN_VALUE;
		var filePath = resource.URI.lastSegment;
		filePath = filePath.substring(0, filePath.lastIndexOf('.'))
		var fileList = new StringBuilder(10000000);
		logsNumberOfEntries = new ArrayList<Integer>()
		logsNumberOfEntriesIntermediate= new ArrayList<Integer>()
		overshootquantcournter = 0
		undershootquantcournter = 0

		risequantcournter = 0

		fallquantcournter = 0
		osccounter = 0;

		nummax = 0;
		nummin = 0;
		spikecounter = 0;

		// contains the scripts that executes all the properties
		val suggestedSampleSteps = new HashMap<String, Integer>();
		val usedSampleSteps = new HashMap<String, Double>();

		for (hls : resource.allContents.toIterable.filter(Hls)) {
			if (hls.instructions.instructions == "generate") {
				generate = true
			}
		}

		if (generate) {

			for (trace : resource.allContents.toIterable.filter(Trace)) {

				val requirementNames = new HashSet;
				for (req : trace.requirementref) {
					requirementNames.add(req.name)
				}

				for (requirement : resource.allContents.toIterable.filter(Requirement)) {

					if (requirementNames.contains(requirement.name)) {

						val originalTraceFilepath = trace.filePath as String
						var orifinalFilePath = ".." + File.separator + originalTraceFilepath;

						var signals = newArrayList

						var map = newHashMap

						for (nc : requirement.variables) {
							switch nc {
								Signal: {
									var interpol = 'Constant'
									if (nc.interpolationType !== null) {
										interpol = nc.interpolationType as String
									}
									var signal = nc.name as String
									signals.add(signal)
									map.put(signal, interpol)

								}
							}
						}

						// STEP 1 - FILTERING


						var filteredFilePath =  ".." + File.separator + "traces-gen-step1" + File.separator +
							requirement.name + "_" + trace.name + ".tsv";
						fsa.deleteFile(filteredFilePath);

						var p=new Preprocessing();
						var numRecords = p.filter(fsa, orifinalFilePath, filteredFilePath, signals);

						minDeltaTime=Math.min(minDeltaTime,p.maxSimulationTime-p.minSimulationTime);
						maxDeltaTime=Math.max(maxDeltaTime,p.maxSimulationTime-p.minSimulationTime);
						logsNumberOfEntriesIntermediate.add(numRecords);
						// STEP 2 - INTERPOLATION
						val processedTraceFilePath = ".." + File.separator + "traces-gen" + File.separator +
							requirement.name + "_" + trace.name + ".csv";

						fsa.deleteFile(processedTraceFilePath);

						var preprocessingResult = true;
						if (resource.allContents.toIterable.filter(Hls).get(0).samplestep.sample == "fixed-manual") {
							if (trace.sampleStep !== null) {
								sampleStepIsConstant = true

								sampleStep = getNumber(trace.sampleStep)
								if (trace.unit as String == '[h]') {
									sampleStep = sampleStep * 3.6 * 1000000000
								}
								if (trace.unit as String == '[min]') {
									sampleStep = sampleStep * 6 * 10000000
								}
								if (trace.unit as String == '[ms]') {
									sampleStep = sampleStep * 1000
								}
								if (trace.unit as String == '[micros]') {
									sampleStep = sampleStep * 1
								}
								if (trace.unit as String == '[nanos]') {
									sampleStep = sampleStep * 0.001
								}
								if (trace.unit as String == '[s]') {
									sampleStep = sampleStep * 1000000
								}
								usedSampleSteps.put(trace.name, sampleStep);

								val preprocessor = new Preprocessing();
								preprocessingResult = preprocessor.executeFixedSampleStep(fsa, filteredFilePath,
									processedTraceFilePath, signals, sampleStep, map, originalTraceFilepath,
									requirement.name, trace.name, logsNumberOfEntries, suggestedSampleSteps)
								preprocessor.checkCorrectness;

								//println("Pre-processed trace: " + processedTraceFilePath + " correctly generated");

								filteredFilePath = processedTraceFilePath
							} else {
								throw new Error("You must specify a sample step when fixed-manual is selected")
							}
						} else {
							if (resource.allContents.toIterable.filter(Hls).get(0).samplestep.sample == "fixed-min") {
								sampleStepIsConstant = true

								println("Sample step: fixed-min sample step selected")

								val preprocessor = new Preprocessing();
								sampleStep = preprocessor.getSampleStep(fsa, filteredFilePath, signals)

								preprocessingResult = preprocessor.executeFixedSampleStep(fsa, filteredFilePath,
									processedTraceFilePath, signals, sampleStep, map, originalTraceFilepath,
									requirement.name, trace.name, logsNumberOfEntries, suggestedSampleSteps)
								preprocessor.checkCorrectness;

								//println("Pre-processed trace: " + processedTraceFilePath + " correctly generated");

								filteredFilePath = processedTraceFilePath
							}
							else{
								sampleStepIsConstant=false;
								val preprocessor = new Preprocessing();

								preprocessingResult = preprocessor.executeVariableSampleStep(fsa, filteredFilePath,
									processedTraceFilePath, signals, sampleStep, map, originalTraceFilepath,
									requirement.name, trace.name, logsNumberOfEntries, suggestedSampleSteps)
								preprocessor.checkCorrectness;

								//println("Pre-processed trace: " + processedTraceFilePath + " correctly generated");

								filteredFilePath = processedTraceFilePath


							}

						}

						// STEP 2 - SMT TRANSLATION GENERATION
						var sb = new StringBuilder();
						sb.append(space + "start_time=time.time()\n")
						sb.append(space + "z3solver=Solver() \n");

						if (preprocessingResult) {
							val tracefile = processfile(fsa, filteredFilePath)

							for (nc : requirement.variables) {
								switch nc {
									SampleVariable: {
										sb.append(space + nc.name + "=Int('" + nc.name + "') \n")
									}
									TimeVariable: {
										sb.append(space + nc.name + "=Real('" + nc.name + "') \n")
									}
									NumericVariable: {
										sb.append(space + nc.name + "=Real('" + nc.name + "') \n")
									}
									Signal: {
										sb.append('\n' + space + '#' + nc.name + ' contained in the file\n')

									}
								}
							}

							sb.append('\n' + space + '#Trace: ' + requirement.name + "\n" + tracefile)

							// /////////////////////////////////////////////////////////////////////
							lastSample = countTimestamps(fsa, filteredFilePath) - 1

							if (trace.sampleStep !== null) {
								lastTimeStamp = lastSample * sampleStep
							}
							// /////////////////////////////////////////////////////////////////////
							sb.append('\n' + space + '# this is the first time stamp ' + (firstTimeStamp.intValue) +
								'\n')
							sb.append('\n' + space + '# this is the last time stamp ' + lastTimeStamp.intValue + '\n')
							sb.append('\n' + space + '# this is the sample step ' + sampleStep.intValue + '\n')
							sb.append('\n' + space + '# the total number of samples is ' + lastSample.intValue + '\n')

							if (requirement.spec !== null && requirement.spec.expression !== null) {
								var req = requirement.spec.expression
								var header = "from z3 import *\n" + "import time\n"
								header += "def " + requirement.name + "():\n";

								val sharedText = header + sb.toString
								var particularText = new StringBuilder
								definitions = ''
								timeindex = 0
								var body = formulaRecursion(requirement.spec.expression)
								particularText.append('\n' + definitions)
								particularText.append('\n' + space + "z3solver.add(Not(" + body + "))")
								particularText.append('\n' + space + 'status=z3solver.check()\n' + space +
									'print(status)\n')
								particularText.append('\n' + space +
									'print("--- %s seconds ---" % (time.time() - start_time))\n')

								particularText.append(
									space + 'if status == sat: ' + '\n\t' + space + 'print("REQUIREMENT VIOLATED")' +
										'\n' + space + space + 'return 0\n' + space + 'if status == unsat:' + '\n\t' +
										space + 'print("REQUIREMENT SATISFIED")' + '\n' + space + space + 'return 1\n' +
										space + 'else:' + '\n\t' + space + 'print("UNDECIDED")' + '\n' + space + space +
										'return 2\n'
								)

								particularText.append('\n\n\n\n');
								particularText.append('if __name__ == "__main__":\n');
								particularText.append(space + requirement.name + '()');
								val ptclrtxt = particularText.toString
								val name = requirement.name + '_' + trace.name + ".py";
								val value = "# Z3Py CODE: \n" + sharedText + ptclrtxt;

								fsa.generateFile(name, value)

								fileList.append(requirement.name + ',' + trace.name + "\n");

							}
						}
					}
				}
			}

			fsa.generateFile(filePath + "matches.csv", fileList.toString)

		} else {

			for (trace : resource.allContents.toIterable.filter(Trace)) {

				val requirementNames = new HashSet;
				for (req : trace.requirementref) {
					requirementNames.add(req.name)
				}

				for (requirement : resource.allContents.toIterable.filter(Requirement)) {

					if (requirementNames.contains(requirement.name)) {
						val originalTraceFilepath = trace.filePath as String
						var tracefilepath = ".." + File.separator + originalTraceFilepath;

						val processedTraceFilePath = ".." + File.separator + "traces-gen" + File.separator +
							requirement.name + "_" + trace.name + ".csv";

						fsa.deleteFile(processedTraceFilePath);
						var sb = new StringBuilder();
						sb.append(space + "start_time=time.time()\n")
						sb.append(space + "z3solver=Solver() \n");

						var signals = newArrayList

						var map = newHashMap

						for (nc : requirement.variables) {
							switch nc {
								Signal: {
									var interpol = 'Constant'
									if (nc.interpolationType !== null) {
										interpol = nc.interpolationType as String
									}
									var signal = nc.name as String
									signals.add(signal)
									map.put(signal, interpol)

								}
							}
						}
						val preprocessor = new Preprocessing();
						preprocessor.executecheck(fsa, tracefilepath, processedTraceFilePath, signals, sampleStep, map,
							originalTraceFilepath, requirement.name, trace.name)
						preprocessor.checkCorrectness;

					}
				}
			}
		}

		if (resource.allContents.toIterable.filter(Hls).get(0).instructions.instructions == "fixed-manual") {
			println("*******************************************************");
			println("Suggested and Used Sample steps")
			for (Entry e : suggestedSampleSteps.entrySet) {
				println(
					"Trace: " + e.key + "\t Suggested Value: " + e.value + " [micros]" + "\t Used Value: " +
						usedSampleSteps.get(e.key) + "[micros]")
			}
		}

		println("*******************************************************");

		println("File: " + filePath)
		println("____________________________");
		println("#Requirements: " + resource.allContents.toIterable.filter(Requirement).size)
		println("#Specification: " + resource.allContents.toIterable.filter(Specitication).size)

		println("#Time Quantifier: " +
			(resource.allContents.toIterable.filter(TimeQuantifier).size +
				resource.allContents.toIterable.filter(Rise).size * 2 +
				resource.allContents.toIterable.filter(Fall).size * 2 +
				resource.allContents.toIterable.filter(Undershoot).size * 2 +
				resource.allContents.toIterable.filter(Overshoot).size * 2))

		println("#Index Quantifier: " +
			(resource.allContents.toIterable.filter(SampleQuantifier).size+
				resource.allContents.toIterable.filter(Spike).size * 33 +
				resource.allContents.toIterable.filter(Oscillation).size * 35)

		)


		//println("#Quantifier Real Value: " + resource.allContents.toIterable.filter(VariableQuantifier).size)

		//println("#tm: " + resource.allContents.toIterable.filter(RetrieveTimeStampFromSample).size)

		//println("#sm: " + resource.allContents.toIterable.filter(RetrieveSampleFromTimeStamp).size)
		if (logsNumberOfEntriesIntermediate.size() > 0) {

			//println("-------------------------------------------- Intermediate File -----------")
			//println("#Number of couples requirements-trace: " + logsNumberOfEntriesIntermediate.size())
			//println("#Trace max entries: " + logsNumberOfEntriesIntermediate.stream.max(Comparator.<Integer>naturalOrder()))
			//println("#Trace min entries: " + logsNumberOfEntriesIntermediate.stream.min(Comparator.<Integer>naturalOrder()))

			val avg = avgf(logsNumberOfEntriesIntermediate);
			//println("#Trace avg entries: " + avg)


			//println("#Trace std entries: " + stdevv(logsNumberOfEntriesIntermediate,avg));
		}
		if (logsNumberOfEntries.size() > 0) {

			//println("-------------------------------------------- Final File -----------")
			//println("#Number of couples requirements-trace: " + logsNumberOfEntries.size())
			//println("#Trace max entries: " + logsNumberOfEntries.stream.max(Comparator.<Integer>naturalOrder()))
			//println("#Trace min entries: " + logsNumberOfEntries.stream.min(Comparator.<Integer>naturalOrder()))

			val avg = avgf(logsNumberOfEntries);
			//println("#Trace avg entries: " + avg)
			//println("#Trace std entries: " + stdevv(logsNumberOfEntries,avg))
		}
		//print("Max simulation time: "+maxDeltaTime)
		//print("Min simulation time: "+minDeltaTime)


	// println("#Trace std entries: "+logsNumberOfEntries.stream.min(Comparator.<Integer>naturalOrder())/logsNumberOfEntries.size())
	}

	def double avgf(ArrayList<Integer> intvalues){
		var avg=0.0
		for (v: intvalues){
			avg=avg+v
		}
		return avg/intvalues.size();

	}

	def double stdevv(ArrayList<Integer> intvalues,double avg){
		var stdv=0.0
		for (v: intvalues){
			stdv=stdv+Math.pow((v-avg),2)
		}
		return Math.sqrt((stdv/intvalues.size()));

	}
}
